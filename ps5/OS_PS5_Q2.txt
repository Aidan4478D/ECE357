a) So on page 33 of the lecture notes you talk about stack growth. What you say is basically that if the stack pointer is lower than the start of the stack region, then we will incur a fault. The faulted address is "close" to the lowest valid address of the stack region, and if the memory region just above the faulted address has the GROWSDOWN property, then the stack region will be expanded by one page down (lower address) as if by the mremap system call. So we allocate a new page frame, make a PTE mapping for the new stack page and try the instruction again. It's a minor fault, almost forgot to say that. 

b) Ok this is a demand paging situation. We will need to read from the disk, because nothing on the system or our process has ever read that file. This is an example of a major fault, in which it is necessary to sleep pending an I/O operation to satisfy this fault. So what will happen is "ask the filesystem module to initiate a disk read operation, depositing the result in physical page new_pf. This puts the task into a non-interruptable SLEEPING state until the I/O operation completes (or fails)." When the I/O completes (hopefully), we update the PTE to point to the new page frame, set the appropriate permission bits, mark as present and return to try the instruction. 

c) Well in this case, the kernel will deliver a SIGBUS to the process. When we unplugged the USB stick the backing store (the file that is on the USB) is no longer accessible in the filesystem so the kernel has no choice but to return a SIGBUS. 

d) The memory permissions for BSS state that, "he bss region is created, with the size requested in the a.out header, as a MAP_ANONYMOUS|MAP_PRIVATE mapping, with PROT_READ|PROT_WRITE protections. As it is accessed, the kernel will allocate page frames, zero-filling them first." But you say nothing about PROT_EXEC. So we believe that when the program tries to execute (fetch instructions) the BSS region, this will end up causing a protection violation (again no execute permission). And later in the notes you say that "If the attempted access is a violation of the region's protections, a signal SIGSEGV is forcibly posted to the current process." So process will get a SIGSEGV. 

e) The lecture notes (pg 46) say that, "When an mmap region is established with MAP_ANONYMOUS | MAP_SHARED, it is clearly anonymous: no part of any file corresponds to it. But in order for it to work correctly when shared among multiple address spaces, the Linux kernel must resort to a trick. Consider what would happen if such a region is created and then is being shared by two processes after a fork. Process A demand-pages in a page of this region for the first time. Since it is anonymous, the kernel satisfies this as a minor fault with a zero-filled page frame." So, since this is the first access to an anonymous page, also there is no I/O required because its anonymous, it just needs zero-filling. This means that this will be resolved as a minor fault, the kernel will just allocated a new page frame, fill it with zeros, and make the mapping. 

f) This is a major page fault. If we translate 0x00ECE466 (COMPILERS???) to binary -> 0000 0000 1110 1100 1110 0100 0110 0110 we can see that bit 31 (present bit) is 0. This means that the page is not present in memory. Also, our PFN is not a bunch of zeros, but a number. From lecture notes, "The kernel deliberately sets up this odd situation to indicate an anonymous page which has been swapped out. The page frame number does not correspond to a real address, but is used as an identifier to help the swap subsystem find the image of the page in the swap area. We will need to initiate an I/O operation to swap-in the page image to a new page frame." So this would result in a major page fault as we need to initiate an I/O operation.